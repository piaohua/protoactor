// Code generated by protoc-gen-gogo.
// source: vo.proto
// DO NOT EDIT!

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 玩家的详细数据
type UserData struct {
	Userid     string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname   string `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Phone      string `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Sex        uint32 `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Status     uint32 `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	Photo      string `protobuf:"bytes,6,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin       uint32 `protobuf:"varint,8,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond    uint32 `protobuf:"varint,9,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Win        uint32 `protobuf:"varint,10,opt,name=win,proto3" json:"win,omitempty"`
	Lost       uint32 `protobuf:"varint,11,opt,name=lost,proto3" json:"lost,omitempty"`
	Ping       uint32 `protobuf:"varint,12,opt,name=ping,proto3" json:"ping,omitempty"`
	Piao       uint32 `protobuf:"varint,13,opt,name=piao,proto3" json:"piao,omitempty"`
	Roomtype   uint32 `protobuf:"varint,14,opt,name=roomtype,proto3" json:"roomtype,omitempty"`
	Roomid     uint32 `protobuf:"varint,15,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Invitecode string `protobuf:"bytes,16,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
}

func (m *UserData) Reset()                    { *m = UserData{} }
func (*UserData) ProtoMessage()               {}
func (*UserData) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{0} }

func (m *UserData) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *UserData) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *UserData) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *UserData) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *UserData) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UserData) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *UserData) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *UserData) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *UserData) GetWin() uint32 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *UserData) GetLost() uint32 {
	if m != nil {
		return m.Lost
	}
	return 0
}

func (m *UserData) GetPing() uint32 {
	if m != nil {
		return m.Ping
	}
	return 0
}

func (m *UserData) GetPiao() uint32 {
	if m != nil {
		return m.Piao
	}
	return 0
}

func (m *UserData) GetRoomtype() uint32 {
	if m != nil {
		return m.Roomtype
	}
	return 0
}

func (m *UserData) GetRoomid() uint32 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *UserData) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

// 玩家在房间内的基础数据
type RoomUser struct {
	Userid    string   `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname  string   `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Seat      uint32   `protobuf:"varint,3,opt,name=seat,proto3" json:"seat,omitempty"`
	Sex       uint32   `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Photo     string   `protobuf:"bytes,5,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin      uint32   `protobuf:"varint,7,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond   uint32   `protobuf:"varint,8,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Ready     bool     `protobuf:"varint,9,opt,name=ready,proto3" json:"ready,omitempty"`
	Win       uint32   `protobuf:"varint,10,opt,name=win,proto3" json:"win,omitempty"`
	Lost      uint32   `protobuf:"varint,11,opt,name=lost,proto3" json:"lost,omitempty"`
	Ping      uint32   `protobuf:"varint,12,opt,name=ping,proto3" json:"ping,omitempty"`
	Piao      uint32   `protobuf:"varint,13,opt,name=piao,proto3" json:"piao,omitempty"`
	Score     int32    `protobuf:"varint,14,opt,name=score,proto3" json:"score,omitempty"`
	Value     uint32   `protobuf:"varint,15,opt,name=value,proto3" json:"value,omitempty"`
	Handcards []uint32 `protobuf:"varint,16,rep,packed,name=handcards" json:"handcards,omitempty"`
}

func (m *RoomUser) Reset()                    { *m = RoomUser{} }
func (*RoomUser) ProtoMessage()               {}
func (*RoomUser) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{1} }

func (m *RoomUser) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomUser) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *RoomUser) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomUser) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *RoomUser) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *RoomUser) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *RoomUser) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *RoomUser) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *RoomUser) GetWin() uint32 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *RoomUser) GetLost() uint32 {
	if m != nil {
		return m.Lost
	}
	return 0
}

func (m *RoomUser) GetPing() uint32 {
	if m != nil {
		return m.Ping
	}
	return 0
}

func (m *RoomUser) GetPiao() uint32 {
	if m != nil {
		return m.Piao
	}
	return 0
}

func (m *RoomUser) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RoomUser) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *RoomUser) GetHandcards() []uint32 {
	if m != nil {
		return m.Handcards
	}
	return nil
}

// 房间数据
type RoomData struct {
	Roomid     uint32 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype      uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname      string `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Expire     uint32 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	Count      uint32 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Invitecode string `protobuf:"bytes,6,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
	Dealer     uint32 `protobuf:"varint,7,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Round      uint32 `protobuf:"varint,8,opt,name=round,proto3" json:"round,omitempty"`
	Userid     string `protobuf:"bytes,9,opt,name=userid,proto3" json:"userid,omitempty"`
	State      bool   `protobuf:"varint,10,opt,name=state,proto3" json:"state,omitempty"`
	Cards      uint32 `protobuf:"varint,11,opt,name=cards,proto3" json:"cards,omitempty"`
	Dice       uint32 `protobuf:"varint,12,opt,name=dice,proto3" json:"dice,omitempty"`
	Turn       uint32 `protobuf:"varint,13,opt,name=turn,proto3" json:"turn,omitempty"`
	Laipi      uint32 `protobuf:"varint,14,opt,name=laipi,proto3" json:"laipi,omitempty"`
	Laizi      uint32 `protobuf:"varint,15,opt,name=laizi,proto3" json:"laizi,omitempty"`
}

func (m *RoomData) Reset()                    { *m = RoomData{} }
func (*RoomData) ProtoMessage()               {}
func (*RoomData) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{2} }

func (m *RoomData) GetRoomid() uint32 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RoomData) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *RoomData) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *RoomData) GetExpire() uint32 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *RoomData) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RoomData) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

func (m *RoomData) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *RoomData) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *RoomData) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomData) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

func (m *RoomData) GetCards() uint32 {
	if m != nil {
		return m.Cards
	}
	return 0
}

func (m *RoomData) GetDice() uint32 {
	if m != nil {
		return m.Dice
	}
	return 0
}

func (m *RoomData) GetTurn() uint32 {
	if m != nil {
		return m.Turn
	}
	return 0
}

func (m *RoomData) GetLaipi() uint32 {
	if m != nil {
		return m.Laipi
	}
	return 0
}

func (m *RoomData) GetLaizi() uint32 {
	if m != nil {
		return m.Laizi
	}
	return 0
}

// 房间桌面牌数据(重复进入房间时数据)
type RoomCards struct {
	Seat     uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Peng     []uint32 `protobuf:"varint,2,rep,packed,name=peng" json:"peng,omitempty"`
	Kong     []uint32 `protobuf:"varint,3,rep,packed,name=kong" json:"kong,omitempty"`
	Outcards []uint32 `protobuf:"varint,4,rep,packed,name=outcards" json:"outcards,omitempty"`
}

func (m *RoomCards) Reset()                    { *m = RoomCards{} }
func (*RoomCards) ProtoMessage()               {}
func (*RoomCards) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{3} }

func (m *RoomCards) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomCards) GetPeng() []uint32 {
	if m != nil {
		return m.Peng
	}
	return nil
}

func (m *RoomCards) GetKong() []uint32 {
	if m != nil {
		return m.Kong
	}
	return nil
}

func (m *RoomCards) GetOutcards() []uint32 {
	if m != nil {
		return m.Outcards
	}
	return nil
}

// 结算数据
type RoomOver struct {
	Seat       uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid     string   `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Cards      []uint32 `protobuf:"varint,3,rep,packed,name=cards" json:"cards,omitempty"`
	Hu         uint32   `protobuf:"varint,4,opt,name=hu,proto3" json:"hu,omitempty"`
	HuTypeFan  int32    `protobuf:"varint,5,opt,name=huTypeFan,proto3" json:"huTypeFan,omitempty"`
	HuFan      int32    `protobuf:"varint,6,opt,name=huFan,proto3" json:"huFan,omitempty"`
	MingKong   int32    `protobuf:"varint,7,opt,name=mingKong,proto3" json:"mingKong,omitempty"`
	BeMingKong int32    `protobuf:"varint,8,opt,name=beMingKong,proto3" json:"beMingKong,omitempty"`
	AnKong     int32    `protobuf:"varint,9,opt,name=anKong,proto3" json:"anKong,omitempty"`
	BuKong     int32    `protobuf:"varint,10,opt,name=buKong,proto3" json:"buKong,omitempty"`
	Total      int32    `protobuf:"varint,11,opt,name=total,proto3" json:"total,omitempty"`
	Coin       int32    `protobuf:"varint,12,opt,name=coin,proto3" json:"coin,omitempty"`
	Score      int32    `protobuf:"varint,13,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *RoomOver) Reset()                    { *m = RoomOver{} }
func (*RoomOver) ProtoMessage()               {}
func (*RoomOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{4} }

func (m *RoomOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomOver) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomOver) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *RoomOver) GetHu() uint32 {
	if m != nil {
		return m.Hu
	}
	return 0
}

func (m *RoomOver) GetHuTypeFan() int32 {
	if m != nil {
		return m.HuTypeFan
	}
	return 0
}

func (m *RoomOver) GetHuFan() int32 {
	if m != nil {
		return m.HuFan
	}
	return 0
}

func (m *RoomOver) GetMingKong() int32 {
	if m != nil {
		return m.MingKong
	}
	return 0
}

func (m *RoomOver) GetBeMingKong() int32 {
	if m != nil {
		return m.BeMingKong
	}
	return 0
}

func (m *RoomOver) GetAnKong() int32 {
	if m != nil {
		return m.AnKong
	}
	return 0
}

func (m *RoomOver) GetBuKong() int32 {
	if m != nil {
		return m.BuKong
	}
	return 0
}

func (m *RoomOver) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *RoomOver) GetCoin() int32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *RoomOver) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 投票信息
type RoomVote struct {
	Seat     uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Agree    []uint32 `protobuf:"varint,2,rep,packed,name=agree" json:"agree,omitempty"`
	Disagree []uint32 `protobuf:"varint,3,rep,packed,name=disagree" json:"disagree,omitempty"`
}

func (m *RoomVote) Reset()                    { *m = RoomVote{} }
func (*RoomVote) ProtoMessage()               {}
func (*RoomVote) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{5} }

func (m *RoomVote) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomVote) GetAgree() []uint32 {
	if m != nil {
		return m.Agree
	}
	return nil
}

func (m *RoomVote) GetDisagree() []uint32 {
	if m != nil {
		return m.Disagree
	}
	return nil
}

func init() {
	proto.RegisterType((*UserData)(nil), "messages.UserData")
	proto.RegisterType((*RoomUser)(nil), "messages.RoomUser")
	proto.RegisterType((*RoomData)(nil), "messages.RoomData")
	proto.RegisterType((*RoomCards)(nil), "messages.RoomCards")
	proto.RegisterType((*RoomOver)(nil), "messages.RoomOver")
	proto.RegisterType((*RoomVote)(nil), "messages.RoomVote")
}
func (this *UserData) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UserData)
	if !ok {
		that2, ok := that.(UserData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	if this.Win != that1.Win {
		return false
	}
	if this.Lost != that1.Lost {
		return false
	}
	if this.Ping != that1.Ping {
		return false
	}
	if this.Piao != that1.Piao {
		return false
	}
	if this.Roomtype != that1.Roomtype {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	return true
}
func (this *RoomUser) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomUser)
	if !ok {
		that2, ok := that.(RoomUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	if this.Ready != that1.Ready {
		return false
	}
	if this.Win != that1.Win {
		return false
	}
	if this.Lost != that1.Lost {
		return false
	}
	if this.Ping != that1.Ping {
		return false
	}
	if this.Piao != that1.Piao {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if len(this.Handcards) != len(that1.Handcards) {
		return false
	}
	for i := range this.Handcards {
		if this.Handcards[i] != that1.Handcards[i] {
			return false
		}
	}
	return true
}
func (this *RoomData) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomData)
	if !ok {
		that2, ok := that.(RoomData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Expire != that1.Expire {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Cards != that1.Cards {
		return false
	}
	if this.Dice != that1.Dice {
		return false
	}
	if this.Turn != that1.Turn {
		return false
	}
	if this.Laipi != that1.Laipi {
		return false
	}
	if this.Laizi != that1.Laizi {
		return false
	}
	return true
}
func (this *RoomCards) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomCards)
	if !ok {
		that2, ok := that.(RoomCards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Peng) != len(that1.Peng) {
		return false
	}
	for i := range this.Peng {
		if this.Peng[i] != that1.Peng[i] {
			return false
		}
	}
	if len(this.Kong) != len(that1.Kong) {
		return false
	}
	for i := range this.Kong {
		if this.Kong[i] != that1.Kong[i] {
			return false
		}
	}
	if len(this.Outcards) != len(that1.Outcards) {
		return false
	}
	for i := range this.Outcards {
		if this.Outcards[i] != that1.Outcards[i] {
			return false
		}
	}
	return true
}
func (this *RoomOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomOver)
	if !ok {
		that2, ok := that.(RoomOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Hu != that1.Hu {
		return false
	}
	if this.HuTypeFan != that1.HuTypeFan {
		return false
	}
	if this.HuFan != that1.HuFan {
		return false
	}
	if this.MingKong != that1.MingKong {
		return false
	}
	if this.BeMingKong != that1.BeMingKong {
		return false
	}
	if this.AnKong != that1.AnKong {
		return false
	}
	if this.BuKong != that1.BuKong {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	return true
}
func (this *RoomVote) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomVote)
	if !ok {
		that2, ok := that.(RoomVote)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Agree) != len(that1.Agree) {
		return false
	}
	for i := range this.Agree {
		if this.Agree[i] != that1.Agree[i] {
			return false
		}
	}
	if len(this.Disagree) != len(that1.Disagree) {
		return false
	}
	for i := range this.Disagree {
		if this.Disagree[i] != that1.Disagree[i] {
			return false
		}
	}
	return true
}
func (this *UserData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&messages.UserData{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "Win: "+fmt.Sprintf("%#v", this.Win)+",\n")
	s = append(s, "Lost: "+fmt.Sprintf("%#v", this.Lost)+",\n")
	s = append(s, "Ping: "+fmt.Sprintf("%#v", this.Ping)+",\n")
	s = append(s, "Piao: "+fmt.Sprintf("%#v", this.Piao)+",\n")
	s = append(s, "Roomtype: "+fmt.Sprintf("%#v", this.Roomtype)+",\n")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&messages.RoomUser{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "Ready: "+fmt.Sprintf("%#v", this.Ready)+",\n")
	s = append(s, "Win: "+fmt.Sprintf("%#v", this.Win)+",\n")
	s = append(s, "Lost: "+fmt.Sprintf("%#v", this.Lost)+",\n")
	s = append(s, "Ping: "+fmt.Sprintf("%#v", this.Ping)+",\n")
	s = append(s, "Piao: "+fmt.Sprintf("%#v", this.Piao)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Handcards: "+fmt.Sprintf("%#v", this.Handcards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&messages.RoomData{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Expire: "+fmt.Sprintf("%#v", this.Expire)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Dice: "+fmt.Sprintf("%#v", this.Dice)+",\n")
	s = append(s, "Turn: "+fmt.Sprintf("%#v", this.Turn)+",\n")
	s = append(s, "Laipi: "+fmt.Sprintf("%#v", this.Laipi)+",\n")
	s = append(s, "Laizi: "+fmt.Sprintf("%#v", this.Laizi)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomCards) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.RoomCards{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Peng: "+fmt.Sprintf("%#v", this.Peng)+",\n")
	s = append(s, "Kong: "+fmt.Sprintf("%#v", this.Kong)+",\n")
	s = append(s, "Outcards: "+fmt.Sprintf("%#v", this.Outcards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&messages.RoomOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Hu: "+fmt.Sprintf("%#v", this.Hu)+",\n")
	s = append(s, "HuTypeFan: "+fmt.Sprintf("%#v", this.HuTypeFan)+",\n")
	s = append(s, "HuFan: "+fmt.Sprintf("%#v", this.HuFan)+",\n")
	s = append(s, "MingKong: "+fmt.Sprintf("%#v", this.MingKong)+",\n")
	s = append(s, "BeMingKong: "+fmt.Sprintf("%#v", this.BeMingKong)+",\n")
	s = append(s, "AnKong: "+fmt.Sprintf("%#v", this.AnKong)+",\n")
	s = append(s, "BuKong: "+fmt.Sprintf("%#v", this.BuKong)+",\n")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomVote) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.RoomVote{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Agree: "+fmt.Sprintf("%#v", this.Agree)+",\n")
	s = append(s, "Disagree: "+fmt.Sprintf("%#v", this.Disagree)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringVo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Status))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	if m.Win != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Win))
	}
	if m.Lost != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Lost))
	}
	if m.Ping != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ping))
	}
	if m.Piao != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Piao))
	}
	if m.Roomtype != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Roomtype))
	}
	if m.Roomid != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Roomid))
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	return i, nil
}

func (m *RoomUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if m.Seat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	if m.Ready {
		dAtA[i] = 0x48
		i++
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Win != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Win))
	}
	if m.Lost != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Lost))
	}
	if m.Ping != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ping))
	}
	if m.Piao != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Piao))
	}
	if m.Score != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Value != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if len(m.Handcards) > 0 {
		dAtA2 := make([]byte, len(m.Handcards)*10)
		var j1 int
		for _, num := range m.Handcards {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *RoomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Roomid))
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Expire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Expire))
	}
	if m.Count != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if m.Round != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.State {
		dAtA[i] = 0x50
		i++
		if m.State {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cards != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Cards))
	}
	if m.Dice != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dice))
	}
	if m.Turn != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Turn))
	}
	if m.Laipi != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Laipi))
	}
	if m.Laizi != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Laizi))
	}
	return i, nil
}

func (m *RoomCards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCards) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Peng) > 0 {
		dAtA4 := make([]byte, len(m.Peng)*10)
		var j3 int
		for _, num := range m.Peng {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Kong) > 0 {
		dAtA6 := make([]byte, len(m.Kong)*10)
		var j5 int
		for _, num := range m.Kong {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.Outcards) > 0 {
		dAtA8 := make([]byte, len(m.Outcards)*10)
		var j7 int
		for _, num := range m.Outcards {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintVo(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *RoomOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Cards) > 0 {
		dAtA10 := make([]byte, len(m.Cards)*10)
		var j9 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.Hu != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Hu))
	}
	if m.HuTypeFan != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.HuTypeFan))
	}
	if m.HuFan != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.HuFan))
	}
	if m.MingKong != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.MingKong))
	}
	if m.BeMingKong != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.BeMingKong))
	}
	if m.AnKong != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.AnKong))
	}
	if m.BuKong != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.BuKong))
	}
	if m.Total != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Total))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Score != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *RoomVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomVote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Agree) > 0 {
		dAtA12 := make([]byte, len(m.Agree)*10)
		var j11 int
		for _, num := range m.Agree {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.Disagree) > 0 {
		dAtA14 := make([]byte, len(m.Disagree)*10)
		var j13 int
		for _, num := range m.Disagree {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func encodeFixed64Vo(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Vo(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	if m.Status != 0 {
		n += 1 + sovVo(uint64(m.Status))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	if m.Win != 0 {
		n += 1 + sovVo(uint64(m.Win))
	}
	if m.Lost != 0 {
		n += 1 + sovVo(uint64(m.Lost))
	}
	if m.Ping != 0 {
		n += 1 + sovVo(uint64(m.Ping))
	}
	if m.Piao != 0 {
		n += 1 + sovVo(uint64(m.Piao))
	}
	if m.Roomtype != 0 {
		n += 1 + sovVo(uint64(m.Roomtype))
	}
	if m.Roomid != 0 {
		n += 1 + sovVo(uint64(m.Roomid))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 2 + l + sovVo(uint64(l))
	}
	return n
}

func (m *RoomUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	if m.Ready {
		n += 2
	}
	if m.Win != 0 {
		n += 1 + sovVo(uint64(m.Win))
	}
	if m.Lost != 0 {
		n += 1 + sovVo(uint64(m.Lost))
	}
	if m.Ping != 0 {
		n += 1 + sovVo(uint64(m.Ping))
	}
	if m.Piao != 0 {
		n += 1 + sovVo(uint64(m.Piao))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Value != 0 {
		n += 1 + sovVo(uint64(m.Value))
	}
	if len(m.Handcards) > 0 {
		l = 0
		for _, e := range m.Handcards {
			l += sovVo(uint64(e))
		}
		n += 2 + sovVo(uint64(l)) + l
	}
	return n
}

func (m *RoomData) Size() (n int) {
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovVo(uint64(m.Roomid))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Expire != 0 {
		n += 1 + sovVo(uint64(m.Expire))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.State {
		n += 2
	}
	if m.Cards != 0 {
		n += 1 + sovVo(uint64(m.Cards))
	}
	if m.Dice != 0 {
		n += 1 + sovVo(uint64(m.Dice))
	}
	if m.Turn != 0 {
		n += 1 + sovVo(uint64(m.Turn))
	}
	if m.Laipi != 0 {
		n += 1 + sovVo(uint64(m.Laipi))
	}
	if m.Laizi != 0 {
		n += 1 + sovVo(uint64(m.Laizi))
	}
	return n
}

func (m *RoomCards) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Peng) > 0 {
		l = 0
		for _, e := range m.Peng {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Kong) > 0 {
		l = 0
		for _, e := range m.Kong {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Outcards) > 0 {
		l = 0
		for _, e := range m.Outcards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	return n
}

func (m *RoomOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Hu != 0 {
		n += 1 + sovVo(uint64(m.Hu))
	}
	if m.HuTypeFan != 0 {
		n += 1 + sovVo(uint64(m.HuTypeFan))
	}
	if m.HuFan != 0 {
		n += 1 + sovVo(uint64(m.HuFan))
	}
	if m.MingKong != 0 {
		n += 1 + sovVo(uint64(m.MingKong))
	}
	if m.BeMingKong != 0 {
		n += 1 + sovVo(uint64(m.BeMingKong))
	}
	if m.AnKong != 0 {
		n += 1 + sovVo(uint64(m.AnKong))
	}
	if m.BuKong != 0 {
		n += 1 + sovVo(uint64(m.BuKong))
	}
	if m.Total != 0 {
		n += 1 + sovVo(uint64(m.Total))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	return n
}

func (m *RoomVote) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Agree) > 0 {
		l = 0
		for _, e := range m.Agree {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Disagree) > 0 {
		l = 0
		for _, e := range m.Disagree {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	return n
}

func sovVo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVo(x uint64) (n int) {
	return sovVo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UserData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserData{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`Win:` + fmt.Sprintf("%v", this.Win) + `,`,
		`Lost:` + fmt.Sprintf("%v", this.Lost) + `,`,
		`Ping:` + fmt.Sprintf("%v", this.Ping) + `,`,
		`Piao:` + fmt.Sprintf("%v", this.Piao) + `,`,
		`Roomtype:` + fmt.Sprintf("%v", this.Roomtype) + `,`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomUser{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`Ready:` + fmt.Sprintf("%v", this.Ready) + `,`,
		`Win:` + fmt.Sprintf("%v", this.Win) + `,`,
		`Lost:` + fmt.Sprintf("%v", this.Lost) + `,`,
		`Ping:` + fmt.Sprintf("%v", this.Ping) + `,`,
		`Piao:` + fmt.Sprintf("%v", this.Piao) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Handcards:` + fmt.Sprintf("%v", this.Handcards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomData{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Expire:` + fmt.Sprintf("%v", this.Expire) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Dice:` + fmt.Sprintf("%v", this.Dice) + `,`,
		`Turn:` + fmt.Sprintf("%v", this.Turn) + `,`,
		`Laipi:` + fmt.Sprintf("%v", this.Laipi) + `,`,
		`Laizi:` + fmt.Sprintf("%v", this.Laizi) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomCards) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomCards{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Peng:` + fmt.Sprintf("%v", this.Peng) + `,`,
		`Kong:` + fmt.Sprintf("%v", this.Kong) + `,`,
		`Outcards:` + fmt.Sprintf("%v", this.Outcards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Hu:` + fmt.Sprintf("%v", this.Hu) + `,`,
		`HuTypeFan:` + fmt.Sprintf("%v", this.HuTypeFan) + `,`,
		`HuFan:` + fmt.Sprintf("%v", this.HuFan) + `,`,
		`MingKong:` + fmt.Sprintf("%v", this.MingKong) + `,`,
		`BeMingKong:` + fmt.Sprintf("%v", this.BeMingKong) + `,`,
		`AnKong:` + fmt.Sprintf("%v", this.AnKong) + `,`,
		`BuKong:` + fmt.Sprintf("%v", this.BuKong) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomVote) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomVote{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Agree:` + fmt.Sprintf("%v", this.Agree) + `,`,
		`Disagree:` + fmt.Sprintf("%v", this.Disagree) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringVo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			m.Win = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Win |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lost", wireType)
			}
			m.Lost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lost |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			m.Ping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ping |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Piao", wireType)
			}
			m.Piao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Piao |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomtype", wireType)
			}
			m.Roomtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			m.Win = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Win |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lost", wireType)
			}
			m.Lost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lost |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			m.Ping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ping |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Piao", wireType)
			}
			m.Piao = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Piao |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Handcards = append(m.Handcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Handcards = append(m.Handcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Handcards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			m.Cards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cards |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dice", wireType)
			}
			m.Dice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dice |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Turn", wireType)
			}
			m.Turn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Turn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laipi", wireType)
			}
			m.Laipi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Laipi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laizi", wireType)
			}
			m.Laizi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Laizi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Peng = append(m.Peng, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Peng = append(m.Peng, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Peng", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Kong = append(m.Kong, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Kong = append(m.Kong, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Kong", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Outcards = append(m.Outcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Outcards = append(m.Outcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hu", wireType)
			}
			m.Hu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HuTypeFan", wireType)
			}
			m.HuTypeFan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HuTypeFan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HuFan", wireType)
			}
			m.HuFan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HuFan |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MingKong", wireType)
			}
			m.MingKong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MingKong |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeMingKong", wireType)
			}
			m.BeMingKong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeMingKong |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnKong", wireType)
			}
			m.AnKong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnKong |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuKong", wireType)
			}
			m.BuKong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuKong |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Agree = append(m.Agree, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Agree = append(m.Agree, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Agree", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Disagree = append(m.Disagree, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Disagree = append(m.Disagree, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Disagree", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVo   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("vo.proto", fileDescriptorVo) }

var fileDescriptorVo = []byte{
	// 702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xcf, 0x6e, 0xd3, 0x4c,
	0x14, 0xc5, 0x63, 0x27, 0x4e, 0x9d, 0x69, 0xd3, 0xaf, 0xb2, 0xa2, 0x4f, 0x23, 0x84, 0xac, 0x2a,
	0xab, 0x2e, 0x10, 0x1b, 0xde, 0x00, 0x10, 0x1b, 0x84, 0x40, 0x16, 0xb0, 0x9f, 0xda, 0x57, 0xc9,
	0xa8, 0xc9, 0x8c, 0x65, 0x8f, 0xd3, 0x96, 0x15, 0x8f, 0xc0, 0x63, 0xf0, 0x10, 0x3c, 0x00, 0xcb,
	0xae, 0x10, 0x4b, 0x6a, 0x58, 0xb0, 0xec, 0x23, 0xa0, 0x7b, 0xef, 0xd8, 0x4d, 0xab, 0xac, 0x10,
	0xbb, 0x7b, 0xce, 0xcd, 0xfc, 0xfb, 0x9d, 0x6b, 0x45, 0xc4, 0x1b, 0xfb, 0xb8, 0xac, 0xac, 0xb3,
	0x49, 0xbc, 0x86, 0xba, 0x56, 0x0b, 0xa8, 0xe7, 0xbf, 0x42, 0x11, 0xbf, 0xab, 0xa1, 0x7a, 0xae,
	0x9c, 0x4a, 0xfe, 0x17, 0xe3, 0xa6, 0x86, 0x4a, 0x17, 0x32, 0x38, 0x0e, 0x4e, 0x26, 0x99, 0x57,
	0xc9, 0x03, 0x11, 0x1b, 0x9d, 0x9f, 0x19, 0xb5, 0x06, 0x19, 0x52, 0xa7, 0xd7, 0xc9, 0x4c, 0x44,
	0xe5, 0xd2, 0x1a, 0x90, 0x43, 0x6a, 0xb0, 0x48, 0x8e, 0xc4, 0xb0, 0x86, 0x0b, 0x39, 0x3a, 0x0e,
	0x4e, 0xa6, 0x19, 0x96, 0xb8, 0x77, 0xed, 0x94, 0x6b, 0x6a, 0x19, 0x91, 0xe9, 0x95, 0x5f, 0xef,
	0xac, 0x1c, 0xf7, 0xeb, 0x9d, 0x4d, 0x12, 0x31, 0xca, 0xad, 0x36, 0x32, 0xa6, 0xdf, 0x52, 0x9d,
	0x48, 0xb1, 0x57, 0x68, 0xb5, 0xb6, 0xa6, 0x90, 0x13, 0xb2, 0x3b, 0x89, 0xa7, 0x9d, 0x6b, 0x23,
	0x05, 0x9f, 0x76, 0xae, 0x0d, 0xae, 0x5f, 0xd9, 0xda, 0xc9, 0x7d, 0x5e, 0x8f, 0x35, 0x7a, 0xa5,
	0x36, 0x0b, 0x79, 0xc0, 0x1e, 0xd6, 0xec, 0x29, 0x2b, 0xa7, 0x9d, 0xa7, 0x2c, 0xbe, 0xb6, 0xb2,
	0x76, 0xed, 0x2e, 0x4b, 0x90, 0x87, 0xe4, 0xf7, 0x1a, 0x5f, 0x81, 0xb5, 0x2e, 0xe4, 0x7f, 0xfc,
	0x0a, 0x56, 0x49, 0x2a, 0x84, 0x36, 0x1b, 0xed, 0x20, 0xb7, 0x05, 0xc8, 0x23, 0x7a, 0xca, 0x96,
	0x33, 0xff, 0x16, 0x8a, 0x38, 0xb3, 0x76, 0x8d, 0xa8, 0xff, 0x0a, 0x73, 0x22, 0x46, 0x35, 0x28,
	0x47, 0x94, 0xa7, 0x19, 0xd5, 0x3b, 0x20, 0xf7, 0x30, 0xa3, 0x5d, 0x30, 0xf7, 0x76, 0xc3, 0x8c,
	0xef, 0xc2, 0x9c, 0x89, 0xa8, 0x02, 0x55, 0x5c, 0x12, 0xe4, 0x38, 0x63, 0xf1, 0x8f, 0x11, 0xcf,
	0x44, 0x54, 0xe7, 0xb6, 0x62, 0xbe, 0x51, 0xc6, 0x02, 0xdd, 0x8d, 0x5a, 0x35, 0xe0, 0xd9, 0xb2,
	0x48, 0x1e, 0x8a, 0xc9, 0x52, 0x99, 0x22, 0x57, 0x55, 0x51, 0xcb, 0xa3, 0xe3, 0xe1, 0xc9, 0x34,
	0xbb, 0x35, 0xe6, 0xad, 0x07, 0xdb, 0xcd, 0xaf, 0x4f, 0x27, 0xb8, 0x93, 0x0e, 0x3e, 0x89, 0xe2,
	0x0c, 0x79, 0x63, 0x12, 0xe4, 0x12, 0x6b, 0x3f, 0xb9, 0x24, 0x70, 0x0f, 0xb8, 0x28, 0x75, 0x05,
	0x9e, 0xab, 0x57, 0xf8, 0xeb, 0xdc, 0x36, 0xc6, 0xf9, 0xf1, 0x65, 0x71, 0x2f, 0xf7, 0xf1, 0xfd,
	0xdc, 0x71, 0xb7, 0x02, 0xd4, 0x0a, 0x2a, 0x0f, 0xdf, 0x2b, 0x3a, 0xdb, 0x36, 0x3d, 0x7c, 0x16,
	0x5b, 0x83, 0x31, 0xb9, 0x33, 0x18, 0x88, 0xcb, 0x29, 0x07, 0x84, 0x3f, 0xce, 0x58, 0xd0, 0x8d,
	0x08, 0xca, 0xbe, 0xbf, 0x11, 0x0a, 0xc4, 0x5d, 0xe8, 0x1c, 0xba, 0x08, 0xb0, 0x46, 0xcf, 0x35,
	0x95, 0xe9, 0x22, 0xc0, 0x1a, 0x57, 0xaf, 0x94, 0x2e, 0xb5, 0x1f, 0x71, 0x16, 0xde, 0xfd, 0xa0,
	0xbb, 0x08, 0x48, 0xcc, 0x73, 0x31, 0x41, 0xc6, 0xcf, 0xba, 0x03, 0x68, 0x12, 0x83, 0xad, 0x49,
	0xc4, 0x8c, 0xc1, 0x2c, 0x64, 0x48, 0xf1, 0x50, 0x8d, 0xde, 0x99, 0x35, 0x0b, 0x39, 0x64, 0x0f,
	0x6b, 0x9c, 0x70, 0xdb, 0x38, 0xbe, 0xf5, 0x88, 0xfc, 0x5e, 0xcf, 0xbf, 0xf8, 0x24, 0x5f, 0x6f,
	0xa0, 0xda, 0x79, 0xc8, 0x2d, 0x9d, 0xf0, 0x3e, 0x1d, 0xde, 0x91, 0x4f, 0xf2, 0x1c, 0x0e, 0x45,
	0xb8, 0x6c, 0x7c, 0x86, 0xe1, 0xb2, 0xa1, 0x31, 0x6a, 0xde, 0x5e, 0x96, 0xf0, 0x42, 0x19, 0xca,
	0x30, 0xca, 0x6e, 0x0d, 0xdc, 0x63, 0xd9, 0x60, 0x67, 0xcc, 0x03, 0x49, 0x02, 0xaf, 0xbb, 0xd6,
	0x66, 0xf1, 0x12, 0x9f, 0xb1, 0x47, 0x8d, 0x5e, 0x63, 0xf2, 0xa7, 0xf0, 0xaa, 0xeb, 0xc6, 0xd4,
	0xdd, 0x72, 0xf0, 0xb6, 0xca, 0x50, 0x6f, 0x42, 0x3d, 0xaf, 0xd0, 0x3f, 0x6d, 0xc8, 0x17, 0xec,
	0xb3, 0xc2, 0x1b, 0x38, 0xeb, 0xd4, 0x8a, 0xd2, 0x8c, 0x32, 0x16, 0xfd, 0xa7, 0x7b, 0x40, 0x26,
	0x7f, 0xba, 0xfd, 0xc7, 0x33, 0xdd, 0xfa, 0x78, 0xe6, 0x6f, 0x98, 0xde, 0x7b, 0xeb, 0x60, 0x27,
	0xbd, 0x99, 0x88, 0xd4, 0xa2, 0x02, 0xf0, 0x19, 0xb1, 0xc0, 0x17, 0x16, 0xba, 0xe6, 0x06, 0xe3,
	0xeb, 0xf5, 0xd3, 0x47, 0x57, 0xd7, 0xe9, 0xe0, 0xfb, 0x75, 0x3a, 0xb8, 0xb9, 0x4e, 0x83, 0x8f,
	0x6d, 0x1a, 0x7c, 0x6e, 0xd3, 0xe0, 0x6b, 0x9b, 0x06, 0x57, 0x6d, 0x1a, 0xfc, 0x68, 0xd3, 0xe0,
	0x77, 0x9b, 0x0e, 0x6e, 0xda, 0x34, 0xf8, 0xf4, 0x33, 0x1d, 0x9c, 0x8e, 0xe9, 0x9f, 0xe5, 0xc9,
	0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0x9e, 0x9c, 0x5c, 0x65, 0x06, 0x00, 0x00,
}
